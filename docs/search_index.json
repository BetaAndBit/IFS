[["index.html", "Gra w chaos z przykładami w języku matematyki, R, Python i Julia 0.1 Dlaczego musiałem napisać tę książkę? 0.2 Jak czytać tę książkę", " Gra w chaos 2022-07-10 z przykładami w języku matematyki, R, Python i Julia 0.1 Dlaczego musiałem napisać tę książkę? Ponad ćwierć wieku temu, w drugiej klasie liceum, mój nauczyciel geometrii - prof. Wiesław Kostarczyk podrzucił mi książkę, która na nowo rozbudziła moje zainteresowanie matematyką. Były to ,,Fraktale od geometrii do sztuki’’ prof. Piotra Pierańskiego. Wtedy rozumiałem być może jedną piątą z tej książki, ale to wystarczyło. Krzywa, która jest tak gęsto upakowana w kwadracie, że choć ma zerowe pole to każdy niezerowy kwadracik zawiera jej kawałek? Dwa równoliczne zbiory, z których jeden na długość 0 a drugi długość 1? Paradoks za paradoksem. Pięć lat później znów trafiłem na fraktale, tym razem podczas studiów informatycznych. Okazało się, że te ciekawe figury mają nie tylko interesujące właściwości matematyczne, ale też bardzo ciekawą konstrukcje którą można zaprogramować! Ech, ile czasu spędziłem na wyszukiwaniu i oprogramowaniu różnych wariantów fraktali (a były to czasy raczkującego Internetu, więc trudno było znaleźć ciekawe konstrukcje, trzeba było głęboko kopać). Gdy 4 lata temu zacząłem pracować nad nowym programem ,,Matematyka Komiksowa’’, który miał na celu pokazać z użyciem komiksu ciekawe wyniki łączące matematyką i informatykę nie miałem wątpliwości! Musiałem napisać historię związaną z fraktalami. Chciałem też by była to wyjątkowa pozycja pokazująca fraktale z wielu perspektyw, ponieważ nigdy nie wiadomo która perspektywa okaże się najbardziej wciągająca. W tej książce znajdziecie urywki z życia trzech wielkich polskich matematyków związanych z fraktalami - Wacława Sierpińskiego, Stefana Banacha i Hugona Steinhausa. Z wyjątkiem pierwszego nie pracowali oni bezpośrednio nad fraktalami, ale jak się okazuje ich wyniki pomagają zrozumieć naturę tych figur. Historie te są pokazane przez krótkie komiksowe historyjki, mam nadzieję, że zainteresują one niektórych czytelników do sięgnięcia głębiej do ich życiorysów. Oczywiście nie mogło zabraknąć przedstawienia wybranych - istotnych twierdzeń - opisujących prawidła rządzące światem fraktali. Starałem się unikać terminologii wykraczającej poza słownik zainteresowanego matematyką licealisty. Mam nadzieję, że to zubożenie słownika zostanie mi wybaczone również przez kolegów matematyków. Zależało mi też na tym by przedstawić w tej książce też dokładne przepisy jak fraktale odtworzyć w zaciszu własnego komputera. Mamy więc programy rysujące fraktale w językach R, Python i Julia. Pisanie tej książki pozwoliło mi na nowo przeżyć ekscytacje sprzed lat bawiąc się w generowanie dziwnych figur. Mam nadzieję, że choć część tych emocji udzieli się też Tobie, drogi czytelniku. Przemysław Biecek. Wilga 2022. 0.2 Jak czytać tę książkę Tutaj będzie opis konstrukcji książki! "],["misja-wacław-sierpiński.html", "Rozdział 1 Misja: Wacław Sierpiński 1.1 Witajcie fraktale! 1.2 Podstawy teoretyczne 1.3 Przykłady w R 1.4 Przykłady w Python 1.5 Przykłady w Julia", " Rozdział 1 Misja: Wacław Sierpiński 1.1 Witajcie fraktale! Beta i Bit spotykają Wacława Sierpińskiego podczas wykładu w Krakowie W bazgrołach znudzonego Bita Wacław Sierpiński dostrzegł arcyciekawą figurę 1.2 Podstawy teoretyczne To fascynujące, że powtarzanie w nieskończoność tych samych czynności może prowadzić to arcyciekawych figur - fraktali. Taką figurę może narysować każdy, wystarczy podstawowa znajomość programowania. Krok po kroku pokażemy jak skonstruować różne klasy fraktali. Znajomość podstaw algebry, prawdopodobieństwa lub topologii pozwala dokładniej zrozumieć skąd się te zaskakujące figury biorą. 1.2.1 Kurz Cantora Jedną z ciekawszych metod konstrukcji fraktali jest metoda ,,przez wygryzanie’’. Bierzemy pewną figurę a następnie usuwamy z niej (wygryzamy) kawałki. To co zostaje jest fraktalem, często o zaskakujących właściwościach. Zilustrujmy to na przykładzie fraktalu nazywanego kurzem Cantora. Receptura na konstrukcje kurzu Cantora jest prosta: Weź odcinek o dowolnej długości (ale dla uproszczenia nasz będzie miał długość 1). Podziel ten odcinek na trzy równe części. Usuń wnętrze środkowej części, przez co otrzymasz dwa odcinki, oba o długości 1/3 wyjściowego odcinka. Dla każdego z otrzymanych odcinków kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 1. Rysunek 1: Pierwsze 5 iteracji w konstrukcji kurzu Cantora Powyższy algorytm ma kilka elementów typowych dla fraktali. Po pierwsze nigdy się nie kończy, całą procedurę należy (przynajmniej w teorii) powtarzać nieskończenie wiele razy. Po drugie, mamy do czynienia z rekurencją, pewien krok prowadzi do powstania zbioru obiektów a następnie każdy z tych obiektów jest ponownie przekształcany w ten sam sposób. W bardzo podobny sposób można otrzymać wiele ciekawych fraktali, ale przyjrzyjmy się jeszcze przez chwilę kurzowi Cantora. Zobaczmy co my właściwie otrzymaliśmy w wyniku tej procedury. Sprawdźmy może jak duży jest ten obiekt lub jaką ma długość. Początkowo odcinek miał długość \\(1\\), ale w pierwszym kroku usunęliśmy \\(1/3\\). W drugim kroku usunęliśmy \\(2\\) razy po \\((1/3)^2\\). Powtarzając to kilkukrotnie w kroku \\(k\\) usuwamy \\(2^{k-1}\\) odcinków, każdy o długości \\((1/3)^k\\). A więc długość tego tworu w kroku \\(k\\) to \\[ 1 - 1/3 - 2*(1/3)^2 - ... - 2^{k-1}*(1/3)^k = 1 - \\sum_{i=1}^k 2^{k-1}*(1/3)^k = 1 - 1/2 \\sum_{i=1}^k (2/3)^k = 0 \\] Do tego samego wniosku można dojść stosując inne rozumowanie, a mianowicie patrząc, ile zostało po \\(k\\) kroku. Po pierwszym kroku mamy \\(2\\) odcinki długości \\(1/3\\), po drugim kroku mamy \\(2^2\\) odcinków długości \\((1/3)^2\\) a po \\(k\\) kroku mamy \\(2^k\\) odcinków o długości \\((1/3)^k\\). Do czego zbiega ten szereg? \\[ \\lim_{k \\rightarrow \\infty} (2/3)^k = 0 \\] Nie ma więc wątpliwości, zbiór Cantora ma długość równą \\(0\\). Ale ewidentnie nie jest zbiorem pustym, bo ma wiele punktów. Jak wiele? Okazuje się, że tyle samo co cały odcinek, a więc nieprzeliczalnie wiele. Pokażmy to za pomocą pewnego sprytnego dowodu. Twierdzenie: Zbiór Cantora jest równoliczny z odcinkiem [0-1). Dowód: Aby policzyć punkty w zbiorze Cantora, potrzebujemy dla każdego punktu skonstruować rodowód, a więc zapis pozwalający jednoznacznie zidentyfikować każdy punkt. Rodowodem jednoznacznie identyfikującym punkt nazwiemy zbiór decyzji, określających jak do tego punktu dotrzeć w kolejnych krokach procedury generującej kurz Cantora. Pamiętamy, że w każdym kroku usuwane są środku z odcinków, więc punkt, który należy do kurzu będzie leżał albo w lewym albo w prawym odcinku. Ten wybór (lewy/prawy) trzeba podjąć w każdym kroku konstrukcji kurzu. Taki rodowód możemy zapisać przez nieskończoną sekwencje cyfr 0/1, jeżeli w sekwencji na pozycji k występuje 0 to punkt należy do lewego pododcinka, jeżeli 1 to do prawego. Zauważmy, jednoznaczność -&gt; każdy punkt z kurzu Cantora może być opisany przez nieskończoną sekwencje cyfr 0/1. Jednocześnie każda nieskończona sekwencja cyfr opisuje jakiś punkt ze zbioru Cantora, a różne sekwencje opisują różne punkty. Ile jest takich sekwencji? Kontinuum. Wystarczy bowiem myśleć o tych sekwencjach jak o rozwinięciach dwójkowych liczb z przedziału [0,1]. Co więc mamy? Kurz Cantora ma tyle samo punktów co odcinek [0,1]. Ale jednocześnie ma długość 0, choć odcinek ma oczywiście długość 1. Jak to możliwe? To jedna z wielu zagadek kryjących się w krainie fraktali malowanych nieskończonością. 1.2.2 Trójkąt Sierpińskiego Jeden z najbardziej znanych fraktali to trójkąt Sierpińskiego. Receptura na konstrukcje tego trójkąt jest dosyć podobna do kurzu Cantora. Oto dokładny przepis: Weź trójkąt równoboczny o dowolnej wielkości (ale dla uproszczenia nasz trójkąt będzie miał długość boku 1). Podziel ten trójkąt na cztery równe trójkąty równoboczne. Usuń środkowy trójkąt, przez co otrzymasz trzy trójkąty, oba o wielkości boku 1/2 wyjściowego trójkąta Dla każdego z otrzymanych trójkątów kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 2. Rysunek 2: Pierwsze cztery iteracje w konstrukcji trójkąta Sierpińskiego Ładny to twór. Ale jakie ma właściwości? Jakie jest jego pole? Tutaj już szybkie rachunki pozwalają rozwiać wszelkie wątpliwości. W kroku \\(k\\) trójkąt składa się z \\(3^k\\) trójkątów, każdy o boku \\((1/2)^k\\), czyli polu \\(\\sqrt{3}/2^{2k+1}\\), czyli o łącznym polu \\((3/4)^k*\\sqrt{3}/2\\). W granicy mamy więc \\[ \\lim_{k \\rightarrow \\infty} (3/4)^k*\\sqrt{3}/2 = 0 \\] Więc trójkąt Sierpińskiego jest tak dziurawy, że ma pole równe 0. A jak długi jest jego brzeg? W kroku \\(k\\) brzeg zwiększa się o \\(3^{k-1}\\) trójkątów, każdy o boku \\((1/2)^k\\), czyli obwodzie \\(3*(1/2)^k\\). Czyli łaczny brzeg w kroku \\(k\\) to \\[ \\sum_{i=1}^k 3^{k-1}*3*(1/2)^k = \\sum_{i=1}^k (3/2)^k. \\] Elementy tego szeregu rosną do nieskończoności, więc tym bardziej cały obwód też eksploduje do nieskończoności. \\[ \\lim_{k \\rightarrow \\infty}\\sum_{i=1}^k (3/2)^k = \\infty \\] Co to za figura, jest ograniczona bo się mieści w trójkącie o boku 1, ale ma nieskończony obwód przy zerowym polu. Z jakiego to jest wymiaru? 1.2.3 Wymiar Hausdorfa Prawdopodobnie do tego miejsca część czytelników zadaje sobie pytanie czym są fraktale. Czy to takie dziwne obrazki? A jeżeli tak to jak je scharakteryzować? Jedną z częściej powtarzanych definicji fraktali jest definicja podana przez Mandelbrota, którą sparafrazuję do: Fraktalem nazywamy taki zbiór, którego wymiar Hausdorfa nie jest liczbą całkowitą. Ok, a czym jest ten wymiar Hausdorfa? Gdy myślimy o przestrzeniach Euklidesowych wymiarem określano liczbę ortogonalnych kierunków/wektorów rozpinających daną przestrzeń. I tak punkt ma wymiar 0, prosta ma wymiar 1, płaszczyzna ma wymiar 2, wszyscy doświadczamy trójwymiarowej przestrzeni. Czasem pewne obiekty możemy opisywać też w przestrzeniach o wyższych wymiarach i nie ma tu żadnych ograniczeń. Matematyk z podekscytowaniem w głosie może opowiadać o przestrzeni funkcji, która jest nieskończenie wymiarowa. Wymiar Hausdorfa określa się dla obiektów geometrycznych zanurzonych w zwykłych \\(p\\)-wymiarowych przestrzeniach (my ograniczymy się praktycznie wyłącznie do \\(p=2\\)). Aby go wyznaczyć, musimy policzyć iloma \\(p\\) wymiarowymi kostkami o boku \\(\\varepsilon\\) można przykryć interesujący nas obiekt. Jeżeli przez \\(N(\\varepsilon)\\) określimy minimalną liczbę kostek pokrywających obiekt \\(F\\) to wymiarem Hausdorfa \\(d_F\\) tego obiektu jest \\[ d_F = \\lim_{\\varepsilon \\rightarrow 0} \\frac{\\log N(\\varepsilon)}{\\log 1/\\varepsilon} \\] Przyjmijmy na razie, że interesują nas kostki o boku \\(\\varepsilon = 2^{-k}\\). Jeżeli chcemy przykryć nimi kwadrat o boku \\(1\\) to potrzebujemy ich przynajmniej \\(N(\\varepsilon) = 2^k * 2^k = 2^{2k}\\). Więc wymiar Hausdorfa kwadratu to \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 2^{2k}}{\\log 1/2^{-k}} = 2 \\] A co z trójkątem Sierpińskiego? Tutaj wystarczy nam \\(N(\\varepsilon) = 3^k\\) kostek o boku \\(2^{-k}\\), a więc wymiar Hausdorfa dla tego trójkąta to \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 3^{k}}{\\log 1/2^{-k}} = \\frac{\\log 3}{\\log 2} = 1,5849... \\] Rysunek 3 ilustruje jak wygląda przykładowe pokrycie trójkąta Sierpińskiego takimi kostkami. Rysunek 3: Pokrycie trójkąta Sierpińskiego kostkmi o boku 1/4 (lewy panel) i 1/8 (prawy panel) A jak to wygląda dla kurzu Cantora? Tym razem mamy obiekt zanurzony w przestrzeni jednowymiarowej, więc będziemy go przykrywać odcinkami. Przyjmijmy, że mamy odcinki o długości \\(\\varepsilon = 3^{-k}\\), aby pokryć cały kurz Cantora wystarczy nam takich odcinków \\(N(\\varepsilon) = 2^k\\), czyli wymiar Hausdorfa dla kurzu Cantora \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 2^{k}}{\\log 1/3^{-k}} = \\frac{\\log 2}{\\log 3} = 0,6309... \\] Wymiar mniejszy niż 1? To nic nadzwyczajnego w świecie fraktali. 1.2.4 Dywan Sierpińskiego Receptura na konstrukcje dywanu Sierpińskiego jest podobna do trójkąta. Oto dokładny przepis: Weź kwadrat o dowolnej wielkości (ale dla uproszczenia nasz kwadrat będzie miał długość boku 1). Podziel ten kwadrat na dziewięć równych kwadratów. Usuń środkowy kwadrat, przez co otrzymasz osiem kwadratów o wielkości boku 1/3 wyjściowego kwadratu. Dla każdego z otrzymanych kwadrat kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 4. Rysunek 4: Pierwsze cztery iteracje w konstrukcji dywanu Sierpińskiego Jaki jest wymiar Hausdorfa tego tworu? Weźmy kostki o wielkości \\(\\varepsilon = 3^{-k}\\). Do zakrycia dywanu wystarczy nam \\(N(\\varepsilon) = 8^k\\) kostek o boku \\(3^{-k}\\). Więc wymiar Hausdorfa dla tego dywanu to \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 8^{k}}{\\log 1/3^{-k}} = \\frac{\\log 8}{\\log 3} = 1,8927... \\] 1.3 Przykłady w R W programie R nie ma funkcji rysującej trójkąty, więc musimy ją najpierw zdefiniować. Do tego celu używamy funkcji polygon, która rysuje wypełnione zamknięte wielokąty. Na jej bazie definiujemy funkcje trojkat rysującą trójkąt równoboczny o boku bok zaczepiony lewym dolnym rogiem w punkcie (x, y). trojkat &lt;- function(x, y, bok) { polygon(x + bok*c(0, 1, 1/2), y + bok*c(0, 0, sqrt(3)/2), col = &quot;black&quot;) } Przetestujmy tę funkcję. Najpierw funkcją plot.new otworzymy nowy obszar do rysowania o wymiarach 1x1 a następnie narysujemy trójkąt o boku 1. plot.new() trojkat(0, 0, 1) Jeżeli chcielibyśmy narysować drugi krok konstrukcji trójkąta Sierpińskiego to musielibyśmy wywołać funkcję trojkat trzy razy. plot.new() trojkat(0, 0, 0.5) trojkat(0.5, 0, 0.5) trojkat(0.25, sqrt(3)/4, 0.5) Aby narysować trzeci krok należałoby wywołać tę funkcję \\(3^2\\) razy. plot.new() trojkat(0, 0, 0.25) trojkat(0.25, 0, 0.25) trojkat(0.125,sqrt(3)/8, 0.25) trojkat(0.5, 0, 0.25) trojkat(0.75, 0, 0.25) trojkat(0.625, sqrt(3)/8, 0.25) trojkat(0.25, sqrt(3)/4, 0.25) trojkat(0.50, sqrt(3)/4, 0.25) trojkat(0.375,3*sqrt(3)/8, 0.25) Rysowanie kolejnych kroków kopiując linijki z funkcją trojkat byłoby niepraktyczne. Znacznie lepiej wykorzystać rekurencje. Poniżej tworzymy funkcje fraktal_trojkat, która w kroku 0 rysuje w trójkąt o zadanym boku a w innych krokach wywoluje się z poleceniem narysowani trzech miejszych fraktali o boku będącym połową wyjściowego. fraktal_trojkat &lt;- function(x, y, bok, krok = 0) { if (krok == 0) { trojkat(x, y, bok) } else { fraktal_trojkat(x, y, bok/2, krok - 1) fraktal_trojkat(x+bok/2, y, bok/2, krok - 1) fraktal_trojkat(x+bok/4, y+sqrt(3)*bok/4, bok/2, krok - 1) } } Wypróbujmy ją! Może na początek ustawmy 5 iteracji, przez co narysujemy \\(3^5 = 243\\) trójkątów. plot.new() fraktal_trojkat(0, 0, bok = 1, krok = 5) Bardzo bardzo mały trójkąt wygląda jak punkt Zamiast rysować trójkąt wystarczy narysować jeden punkt, bo trójkąty po pewnym czasie i tak są strasznie małe. Tyle, że trójkąt Sierpińskiego składająca się z \\(243\\) punktów jest dosyć dziurawa. Dlatego sprawdzimy jak wygląda dla 8 iteracji. plot.new() fraktal_punkt &lt;- function(x, y, bok, krok = 0) { if (krok == 0) { points(x, y, pch=&quot;.&quot;, col=&quot;black&quot;) } else { fraktal_punkt(x, y, bok/2, krok - 1) fraktal_punkt(x+bok/2, y, bok/2, krok - 1) fraktal_punkt(x+bok/4, y+sqrt(3)*bok/4, bok/2, krok - 1) } } fraktal_punkt(0, 0, bok = 1, krok = 8) Ile punktów narysowaliśmy? 1.3.1 Dywan Sierpińskiego w R Prace z fraktalami rozpoczniemy od utkania Dywanu Sierpińskiego. Zaczniemy od jego zubożonej wersji, którą trochę łatwiej opisać na początku, a później pokażemy przepis na kompletny dywan. Jest to dobry fraktal na początek, wystarczy: narysować kwadrat pomniejszyć rysunek 3 razy skopiować 4 razy w cztery rogi kwadratu z otrzymanym rysunkiem wrócić do kroku 2 i tak w nieskończoność. Pierwsze trzy iteracje powyższego schematu przedstawione są na rysunku poniżej. images/fraktale_01.png Ok, spróbujmy to zrobić w R. 1.3.1.1 Narysuj mi kwadrat Zacznijmy od narysowania kwadratu. Pierwsza linijka poniższego przykładu tworzy pusty obszar do rysowania o wymiarach [0,1]x[0,1]. Druga linijka zawiera instrukcje rect(), która rysuje czarny kwadrat rozpięty od punktu (0,0) do (1,1). # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rect(0, 0, 1, 1, col = &quot;black&quot;) W drugiej iteracji ten kwadrat jest trzykrotnie pomniejszany do wymiarów 1/3 x 1/3 i rysowany w czterech rogach. Mamy do narysowania cztery kwadraty i możemy to zrobić w poniższy sposób. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rect(0, 0, 1/3, 1/3, col = &quot;black&quot;) rect(0+2/3, 0, 1/3+2/3, 1/3, col = &quot;black&quot;) rect(0, 0+2/3, 1/3, 1/3+2/3, col = &quot;black&quot;) rect(0+2/3, 0+2/3, 1/3+2/3, 1/3+2/3, col = &quot;black&quot;) W trzeciej iteracji w miejsce każdego z tych czterech kwadratów rysujemy kolejne 4 kwadraty trzykrotnie pomniejszone. W sumie będzie to 16 kwadratów, sporo ale jeszcze damy radę to zapisać. Można to zrobić tak # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rect(0, 0, 1/9, 1/9, col = &quot;black&quot;) rect(0+2/9, 0, 1/9+2/9, 1/9, col = &quot;black&quot;) rect(0, 0+2/9, 1/9, 1/9+2/9, col = &quot;black&quot;) rect(0+2/9, 0+2/9, 1/9+2/9, 1/9+2/9, col = &quot;black&quot;) rect(0+2/3, 0, 1/9+2/3, 1/9, col = &quot;black&quot;) rect(0+2/3+2/9, 0, 1/9+2/3+2/9, 1/9, col = &quot;black&quot;) rect(0+2/3, 0+2/9, 1/9+2/3, 1/9+2/9, col = &quot;black&quot;) rect(0+2/3+2/9, 0+2/9, 1/9+2/3+2/9, 1/9+2/9, col = &quot;black&quot;) rect(0, 0+2/3, 1/9, 1/9+2/3, col = &quot;black&quot;) rect(0+2/9, 0+2/3, 1/9+2/9, 1/9+2/3, col = &quot;black&quot;) rect(0, 0+2/3+2/9, 1/9, 1/9+2/3+2/9, col = &quot;black&quot;) rect(0+2/9, 0+2/3+2/9, 1/9+2/9, 1/9+2/3+2/9, col = &quot;black&quot;) rect(0+2/3, 0+2/3, 1/9+2/3, 1/9+2/3, col = &quot;black&quot;) rect(0+2/3+2/9, 0+2/3, 1/9+2/3+2/9, 1/9+2/3, col = &quot;black&quot;) rect(0+2/3, 0+2/3+2/9, 1/9+2/3, 1/9+2/3+2/9, col = &quot;black&quot;) rect(0+2/3+2/9, 0+2/3+2/9, 1/9+2/3+2/9, 1/9+2/3+2/9, col = &quot;black&quot;) Aby narysować dywan sierpińskiego musimy tę procedurę powtórzyć przynajmniej kilka razy, co wymaga narysowania tysięcy, a często jeszcze większej liczby, kwadratów. Przy takiej liczbie kwadratów kopiowanie kolejnych linijek z wywołaniem funkcji rect nie ma sensu. 1.3.1.2 Rekurencja Zrobimy to sprytniej używając rekurencji, czyli funkcji, która sama siebie wywołuje. Skorzystamy z cechy, która nazywa się samopodobieństwem, czyli cały dywan jest podobny do swoich części. Poniższy przykład przedstawia bardzo sprytną funkcję rysuj_dywan(). Ma ona kilka ciekawych argumentów. Pierwsze dwa x i y wskazują w którym miejscu ma być rysowany dywan, trzeci szerokosc określa szerokość rysowanego dywanu, a ostatni iteracja określa ile iteracji powyższego algorytmu powinniśmy wykonać by narysować dywan. Jeżeli funkcja rysuj_dywan() zostanie wywołana z argumentem iteracja = 0 to narysuje sam kwadrat. Ale jeżeli zostanie wykonana z innym argumentem to narysuje cztery dywany zaczepione w rogach kwadratu o szerokości \\(1/3\\) wyjściowego dywanu. Zobaczmy co z tego wyjdzie! # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan &lt;- function(x, y, szerokosc, iteracja = 0) { if (iteracja == 0) { rect(x, y, x + szerokosc, y + szerokosc, col = &quot;black&quot;) } else { rysuj_dywan(x, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) } } rysuj_dywan(0, 0, szerokosc = 1, iteracja = 2) Możemy teraz w prosty sposób narysować kolejne iteracje małym nakładem kodu. Na trzecim poziomie będzie to \\(4^3 = 64\\) kwadratów. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan(0, 0, szerokosc = 1, iteracja = 3) Zobaczmy jak będzie ta figura wyglądała dla piątej iteracji. Mamy już do czynienia z \\(4^5 = 2^10 = 1024\\) kwadratami. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan(0, 0, szerokosc = 1, iteracja = 5) 1.3.1.3 Prawdziwy dywan Widzimy już jak działa rekurencja oraz co się dzieje w kolejnych iteracjach. Jesteśmy gotowi do narysowania pełnego dywanu Sierpińskiego. Różnica jest taka, że w każdym kroku, zamiast czterech kwadratów w rogach, będziemy rysować 8 kwadratów ,,po obwodzie’’ dużego kwadratu. W poniższej funkcji w każdym kroku z iteracja różnym od 0, rysujemy 8 mniejszych dywanów. rysuj_dywan &lt;- function(x, y, szerokosc, iteracja = 0) { if (iteracja == 0) { rect(x, y, x + szerokosc, y + szerokosc, col = &quot;black&quot;) } else { rysuj_dywan(x, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) } } Rysowanie dywanu dla pięciu iteracji może trochę trwać, ponieważ składa się z \\(8^5 = 2^15 = 32768\\) kwadratów. Ale warto chwilę poczekać by uzyskać taki wynik. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan(0, 0, szerokosc = 1, iteracja = 5) Oczywiście możemy zwiększać liczbę iteracji, ale zmiany na obrazku przestają być zauważalne. 1.3.1.4 Bardzo bardzo mały kwadrat wygląda jak punkt Zauważmy, że narysowany kwadrat bardzo szybko maleje. Maleje wręcz z wykładniczą prędkością. Więc po wielu iteracjach nie musimy rysować kwadratu, wystarczy, że narysujemy punkt, mniej zachodu. Sprawdźmy czy tak faktycznie jest. Zmienimy funkcję rysuj_dywan() by w finalnej iteracji rysowała punkt. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan &lt;- function(x, y, szerokosc, iteracja = 0) { if (iteracja == 0) { points(x, y, col = &quot;black&quot;, pch=&quot;.&quot;) } else { rysuj_dywan(x, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) } } rysuj_dywan(0, 0, szerokosc = 1, iteracja = 5) Tada! Również otrzymujemy dywan, trochę bardziej dziurawy. W zależności od rozdzielczości ekranu warto zwiększyć liczbę iteracji do sześciu lub siedmiu, by dywan się ,,nasycił’’. 1.4 Przykłady w Python Poniższe przykłady korzystają z biblioteki matplotlib w której znajdują się funkcje do rysowania. W szczególności używany jest plot() do rysowania odcinka oraz fill() do rysowania wypełnionych wielokątów, tutaj trójkąta i kwadratu. Czasem potrzebne są funkcje matematyczne, tak by policzyć wysokość trójkąta równobocznego \\(\\sqrt3/2\\), do tego wykorzystywana jest biblioteka math. Aby skrócić zapis operacji na dwuelementowych wektorach (współrzędnych punktów) stosowana jest biblioteka numpy. 1.4.1 Kurz Cantora import matplotlib.pyplot as plt import numpy as np # kurz Cantora o boku scale i głębokości depth def dust(x, scale, depth): if depth &gt; 1: dust(x, scale / 3, depth - 1) dust(x + scale*2/3, scale / 3, depth - 1) else: plt.plot([x, x+scale], [0,0], color = &quot;black&quot;) # inicjacja rysunku i narysowanie trójkąta Sierpińskiego plt.figure() dust(0, scale = 1, depth = 5) plt.show() Kurz Cantora o głębokości 5 1.4.2 Trójkąt Sierpińskiego import matplotlib.pyplot as plt import numpy as np import math # rysuj trójkąt o boku scale zaczepiony w x def triangle(x, scale): plt.fill([x[0], x[0]+scale, x[0]+scale/2], [x[1],x[1],x[1]+scale*math.sqrt(3)/2], color = &quot;black&quot;) # rysuj trojkat Sierpinskiego o boku scale i głębokości depth zaczepiony w x def sierpinski(x, scale, depth): if depth &gt; 1: sierpinski(x, scale / 2, depth - 1) sierpinski(np.add(x, [scale/2, 0]), scale / 2, depth - 1) sierpinski(np.add(x, [scale/4, scale*math.sqrt(3)/4]), scale / 2, depth - 1) else: triangle(x, scale) # inicjacja rysunku i narysowanie trójkąta Sierpińskiego plt.figure() sierpinski([0,0], scale = 1, depth = 4) plt.show() Trójkąt Sierpińskiego o głębokości 4 1.4.3 Dywan Sierpińskiego import matplotlib.pyplot as plt import numpy as np def square(x, scale): plt.fill(np.add(x[0], [0, scale, scale, 0]), np.add(x[1], [0, 0, scale, scale]), color = &quot;black&quot;) # dywan Sierpinskiego o boku scale i głębokości depth def carpet(x, scale, depth): if depth &gt; 1: carpet(x, scale / 3, depth - 1) carpet(np.add(x, [scale/3, 0]), scale / 3, depth - 1) carpet(np.add(x, [2*scale/3, 0]), scale / 3, depth - 1) carpet(np.add(x, [0, scale/3]), scale / 3, depth - 1) carpet(np.add(x, [2*scale/3, scale/3]), scale / 3, depth - 1) carpet(np.add(x, [0, 2*scale/3]), scale / 3, depth - 1) carpet(np.add(x, [scale/3, 2*scale/3]), scale / 3, depth - 1) carpet(np.add(x, [2*scale/3, 2*scale/3]), scale / 3, depth - 1) else: square(x, scale) # inicjacja rysunku i narysowanie trójkąta Sierpińskiego plt.figure() carpet([0,0], scale = 1, depth = 4) plt.show() Dywan Sierpińskiego o głębokości 4 1.5 Przykłady w Julia using Plots function trojkat(x, y, bok) return [(x+bok*0,y+bok*0),(x+bok*1,y+bok*0),(x+bok*1/2,y+bok*sqrt(2)/2),(x+bok*0,y+bok*0)] end # czyścimy ekran E = 0.05 Plots.plot(0,xlim=(0-E,1+E),ylim=(0-E,1+E-0.1)) function rysuj_uszczelke(x, y, szerokosc, iteracja) if iteracja == 0 Plots.plot!(trojkat(x, y, szerokosc), seriestype=:shape, color=:black, legend=:false) else rysuj_uszczelke(x, y, szerokosc / 2, iteracja - 1) rysuj_uszczelke(x+szerokosc / 2, y, szerokosc / 2, iteracja - 1) rysuj_uszczelke(x+szerokosc / 4, y+sqrt(3)*szerokosc/4, szerokosc / 2, iteracja - 1) end current() end rysuj_uszczelke(0, 0, 1, 5) using Plots # czyścimy ekran E = 0.05 Plots.plot(0,xlim=(0-E,1+E),ylim=(0-E,1+E-0.1)) function rysuj_uszczelke(x, y, szerokosc, iteracja) if iteracja == 0 Plots.scatter!([x], [y], markerstrokecolor=:white, markersize=3, color=:black, legend=:false) else rysuj_uszczelke(x, y, szerokosc/2, iteracja - 1) rysuj_uszczelke(x+szerokosc/2, y, szerokosc/2, iteracja - 1) rysuj_uszczelke(x+szerokosc/4, y+sqrt(3)*szerokosc/4, szerokosc/2, iteracja - 1) end current() end rysuj_uszczelke(0, 0, 1, 8) "],["misja-stefan-banach.html", "Rozdział 2 Misja: Stefan Banach 2.1 Fraktale jako punkt stały 2.2 Podstawy teoretyczne 2.3 Przykłady w R 2.4 Przykłady w Python 2.5 Przykłady w Julia", " Rozdział 2 Misja: Stefan Banach 2.1 Fraktale jako punkt stały Beta i Bit spotykają Stefana Banacha w Kawiarni Szkockiej we Lwowie Stefan Banach w marudzeniu znudzonego Bita odnajduje ciekawe twierdzenie 2.2 Podstawy teoretyczne Gwoździem programu w tym rozdziale będzie twierdzenie Banach o punkcie stałem i jego związek z fraktalami. Ale aby docenić piękno tego związku musimy zaznajomić się z pewnymi bardzo abstrakcyjnymi pojęciami. Gdzie się da postaram się pokazywać analogie i intuicje, ale nie łudźmy się. Do pełnego zrozumienia tego związku potrzebujemy pewnego wysiłku. 2.2.1 Przestrzeń metryczna W naszej historii bardzo ważną rolę będą odgrywały odległości pomiędzy punktami. Dlatego dalej w rozdziale często będziemy pisać o przestrzeni metrycznej. Co to takiego? Przestrzeń metryczna to zbiór \\(X\\) z określoną metryką (odległością) \\(d\\) pomiędzy punktami tego zbioru. Inaczej mówiąc, jeżeli pracujemy z przestrzenią metryczną to dla każdej pary punktów potrafimy wyznaczyć ich odległość. Odległość to funkcja dwóch punktów spełniająca jednocześnie trzy warunki: \\(d(a,b) = 0 \\Leftrightarrow a = b\\), odległość wynosi zero wtedy i tylko wtedy gdy punkty są sobie równe, \\(d(a,b) = d(b,a)\\), odległość jest symetryczna, \\(d(a,b) \\leq = d(a,c) + d(c,b)\\), warunek trójkąta, czyli odległość pomiędzy dowolnymi dwoma punktami jest zawsze mniejsza równa niż suma odległości tych punktów od dowolnego innego punktu \\(c\\). Większość z nas (*) codziennym życiu najczęściej operuje w przestrzeni Euklidesową, ze zwykłą ,,linijkową’’ odległością. Ale aby pracować z fraktalami potrzebujemy bardziej wyrafinowanych linijek. (*) czytaj wszyscy, poza topologami. 2.2.2 Odległość Hausdorffa W świecie fraktali odległość pomiędzy punktami mierzy się bardzo przewrotnie - stosując odległość Hausdorffa. Felix Hausdorff - niemiecki matematyk, urodzony we Wrocławiu w 1868, zmarł w Bonn w 1942. Jego główny obszar zainteresował obejmował teorię mnogości i topologię. Mamy dwa zbiory punktów A i B w przestrzeni metrycznej z metryką \\(d\\) i chcemy określić jak daleko są od siebie. Intuicja za tą metryką jest następująca: zbiory są blisko siebie, jeżeli dla każdego punktu z jednego zbioru można znaleźć jakiś punkt z drugiego zbioru, który jest do niego bliski. Jeżeli każdy punkt ze zbioru \\(A\\) ma takiego ,,towarzysza’’ ze zbioru \\(B\\) to są one blisko. Spróbujmy to zapisać formalnie: \\[ d_H(A, B) = max \\left\\{ \\sup_{a\\in A} \\inf_{b\\in B} d(a, b); \\sup_{b \\in B} \\inf_{a \\in A} d(a, b) \\right\\}. \\] Zapis może przerazić, ale jeżeli rozłożyć go na części to okaże się bardzo intuicyjny. Cześć \\(\\inf_{b\\in B} d(a, b)\\) oznacza najmniejszą odległość od punktu \\(a\\) do dowolnego punktu ze zbioru \\(B\\). W takim razie \\(\\sup_{a\\in A} \\inf_{b\\in B} d(a, b)\\) to odległość najbardziej odstającego punktu ze zbioru \\(A\\). Odległość musi być symetryczna, więc we wzorze \\(d_H(A, B)\\) mamy maksimum z odstawiania zbioru \\(A\\) od \\(B\\) i odwrotnie. *Technicznie rzecz biorąc metryka Hausdorffa jest określona dla zwartych niepustych zbiorów. Można ją stosować też dla zbiorów domkniętych, ale wtedy może przyjmować wartości nieskończone. 2.2.3 Ciąg Cauchy’ego Ciąg Cauchy’ego to ciąg punktów, w którym dla dowolnej większej od zera liczby \\(c\\) można znaleźć taki element ciągu \\(N\\), że wszystkie dalsze elementy są od odległości od siebie mniejszej niż \\(c\\). Formalnie zapiszemy to jako \\[ \\forall_{\\varepsilon &gt;0} \\exists_N \\forall_{m,n&gt;N} d(a_m,a_n) \\leq \\varepsilon \\] Ciągi zbieżne spełniają warunek Cauchy’ego, ale są przestrzenie w których ciągi Cauchy’ego nie są zbieżne. To nie są porządne przestrzenie, więc dalej będziemy operować tylko na porządnych przestrzeniach. 2.2.4 Przestrzeń zupełna Przestrzeń metryczna \\((X,d)\\) jest zupełna jeżeli, każdy ciąg \\(a_n \\subset X\\) spełniający warunek Cauchy’ego jest zbieżny \\(X\\). 2.2.5 Kontrakcja Mówimy, że przekształcenie \\(T\\) jest przekształceniem zwężającym (kontrakcją), jeżeli istnieje stała \\(\\lambda \\in (0,1)\\) taka, że \\[ d(T(x), T(y)) \\leq \\lambda d(x,y). \\] Czyli dla dowolnych dwóch punktów \\(x\\) i \\(y\\) po przekształceniu są one bliżej niż przed. 2.2.6 Punkt stały Puntem stałym przekształcenia \\(T\\) jest taki punkt \\(x\\), że \\[ T(x) = x. \\] 2.2.7 Twierdzenie Banacha o punkcie stałym Jeśli \\((X, d)\\) jest przestrzenią metryczną zupełną, a \\(T: X\\to X\\) jest kontrakcją, to \\(T\\) ma dokładnie jeden punkt stały \\(x\\in X\\). Dowód tego twierdzenia Banach przedstawił w swojej pracy doktorskiej. Nie jest on zbyt skomplikowany, ale tutaj ograniczymy się jedynie do pokazania jak szukać tego punktu stałego. Otóż okazuje się, że dla dowolnego punktu \\(x\\) przestrzeni \\(X\\) ciąg \\(T^n(x)\\) zbiega do punktu stałego. Gdzie \\(T^n(x)\\) oznacza n-krotne złożenie przekształcenia \\(T\\), czyli \\(T(T(T(...T(x)...)))\\). Czyli wystarczy w nieskończoność składać kontrakcje by znaleźć ich punkt stały. 2.2.8 Kosinus Ciekawą ilustracją twierdzenia Banacha jest znajdowanie punktu stałego przekształcenia \\(cos()\\). Funkcja \\(cos()\\) jest kontrakcją a prosta rzeczywista \\(R\\) jest przestrzenią metryczną. Aby znaleźć punkt stały tej funkcji wystarczy powtarzać \\(cos(cos(cos(...(x)...)))\\). 2.2.9 Algebra, wszędzie algebra Powyżej opisane przekształcenia to tzw. przekształcenia afiniczne, czyli złożenie skalowania, obrotu i przesunięcia. Skalowanie musi zmniejszać, obrót i przesunięcie mogą być dowolne. Przekształcenia afiniczne można łatwo opisać w postaci algebraicznej, jako mnożenie punktu przez macierz przekształcenia. Pozwoli nam to skrócić zapis kodu, generującego fraktal. W przykładzie poniżej, trans będzie listą transformacji opisanych przez macierz przekształcenia. Na płaszczyźnie, aby opisać skalowanie i obrót wystarczyłaby macierz o wymiarach \\(2\\times 2\\), ale jeżeli chcemy umożliwić przesunięcia, to takie transformacie opiszemy macierzami \\(2\\times 3\\). Mając macierz przekształcenia \\(A\\) możemy wyznaczyć współrzędne punkty po przekształceniu stosując iloczyn macierzowy. W poniższym równaniu dla ułatwienia podano wymiary macierzy. \\[ [x&#39;\\ y&#39;]_{2\\times 1} = A_{2\\times 3} * [x\\ y\\ 1]_{3\\times 1} \\] 2.2.10 Czym jest kontrakcja? 2.2.11 Twierdzenie Banacha o punkcie stałym Nazywane też twierdzeniem Banacha o kontrakcji. 2.3 Przykłady w R Ok, czas to zapisać w R. Obiekt trans będzie listą czterech transformacji a prob będzie prawdopodobieństwem z jakim kolejne transformacje powinny być losowane. N = 50000 point &lt;- c(0, 0) # transformacje trans &lt;- list() trans[[1]] &lt;- matrix(c( 0.85, 0.04, 0, -0.04, 0.85, 1.6), 2, 3, byrow = TRUE) trans[[2]] &lt;- matrix(c(-0.15, 0.28, 0, 0.26, 0.24, 0.44), 2, 3, byrow = TRUE) trans[[3]] &lt;- matrix(c( 0.20, -0.26, 0, 0.23, 0.22, 1.6), 2, 3, byrow = TRUE) trans[[4]] &lt;- matrix(c( 0, 0, 0, 0, 0.16, 0), 2, 3, byrow = TRUE) prob = c(0.85, 0.07, 0.07, 0.01) # czyścimy ekran plot(0, xlim = c(-2.5,3), ylim = c(0,12), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:length(trans), 1, prob = prob) point &lt;- trans[[los]] %*% c(point, 1) points(point[1], point[2], pch = &quot;.&quot;, col=&quot;black&quot;) } 2.3.1 Smok Heighwaya Dobierając różne transformacje uzyskamy bardzo różne fraktale. Przykładowo Smok Heighwaya to złożenie dwóch transformacji \\(x&#39; = -0.4x -1\\), \\(y&#39; = -0.4y + 0.1\\) \\(x&#39; = 0.76x -0.4y\\), \\(y&#39; = 0.4x + 0.76y\\) A tutaj kod w R. Wystarczy zmienić opis transformacji a druga część kodu pozostaje bez zmian. N = 100000 point &lt;- c(0, 0) trans &lt;- list() trans[[1]] &lt;- matrix(c( -0.4, 0, -1, 0, -0.4, 0.1), 2, 3, byrow = TRUE) trans[[2]] &lt;- matrix(c( 0.76, -0.4, 0, 0.4, 0.76, 0), 2, 3, byrow = TRUE) prob = c(0.5, 0.5) # czyścimy ekran plot(0, xlim = c(-1.5,0.5), ylim = c(-1,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:length(trans), 1, prob = prob) point &lt;- trans[[los]] %*% c(point, 1) points(point[1], point[2], pch = &quot;.&quot;, col=&quot;black&quot;) } 2.3.2 Do It Yourself! Poszukaj i spróbuj zaimplementować inne fraktale, jak np: pentagon Sierpińskiego https://larryriddle.agnesscott.org/ifs/pentagon/pentagon.htm płatek Kocha https://larryriddle.agnesscott.org/ifs/ksnow/ksnow.htm McWorter’s Pentigree https://larryriddle.agnesscott.org/ifs/pentigre/pentigre2.htm Opisana powyżej metoda konstrukcji fraktali nazywa się systemem funkcji iterowanych (ang. iterated function system, IFS). Składane funkcje nie muszą być przekształceniami afinicznymi, wystarczy by były kontrakcjami. Eksperymentując z innymi przekształceniami można uzyskać bardzo ciekawe wyniki. 2.4 Przykłady w Python Trójkąt Sierpińskiego # pyplot - biblioteka do rysowania import matplotlib.pyplot as plt # np - operacje na wektorach i macierzach import numpy as np # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) # trojkat Sierpinskiego o głębokości depth def trojkat(x, depth): if depth &gt; 1: x1 = scale(shift(x, [0, 0]), [0.5, 0.5]) trojkat(x1,depth - 1) x2 = scale(shift(x, [0.5, 0]), [0.5, 0.5]) trojkat(x2,depth - 1) x3 = scale(shift(x, [0.25, 0.5]), [0.5, 0.5]) trojkat(x3,depth - 1) else: plt.plot(x[0],x[1], marker=&#39;o&#39;, color = &quot;black&quot;, markersize=3) # inicjacja rysunku i narysowanie trójkąta Sierpińskiego plt.figure(figsize=(8, 6), dpi=80) trojkat([0,0], depth = 8) plt.show() 2.5 Przykłady w Julia "],["misja-hugon-steinhaus.html", "Rozdział 3 Misja: Hugon Steinhaus 3.1 Gra w Chaos 3.2 Podstawy teoretyczne 3.3 Przykłady w R 3.4 Przykłady w Python 3.5 Przykłady w Julia", " Rozdział 3 Misja: Hugon Steinhaus 3.1 Gra w Chaos Beta i Bit trafiają do Krakowa na Planty Rozmowa o całkach przyciąga zainteresowanych słuchaczy Stefana Banacha i Ottona Nikodyma a ich rozmowa przyciąga Hugona Steinhausa 3.2 Podstawy teoretyczne 3.3 Przykłady w R 3.4 Przykłady w Python Pewną wadą rysowania fraktali w sposób opisany powyżej, jest wykładnicze tempo z jakim przybywa nowych obiektów. 8 iteracji to już jest dużo. Gdybyśmy chcieli wykonać 56 iteracji dla dywanu Sierpińskiego to musielibyśmy narysować \\(8^{56} &lt; 10^{50}\\) punktów, czyli więcej niż jest atomów na całej ziemi! Na szczęście jest też druga metoda rysowania fraktali, w której nie musimy używać rekurencji. Musimy za to dużo rysować, ale jak się okaże dzięki temu będziemy w stanie rysować fantastyczne inne fraktale. 3.4.1 Wylosuj mi transformacje Zademonstrujemy grę w chaos na przykładzie uszczelki Sierpińskiego. W poprzednim rozdziale, rysowaliśmy tą uszczelkę rysując trzy mniejsze uszczelki poprzesuwane w rogi trójkąta. Każda z tych uszczelek jest przekształceniem większej uszczelki. Co więcej to tak zwane przekształcenie zwężające (kontrakcja), czyli takie, które zmniejsza odległości pomiędzy punktami. W przypadku naszej uszczelki odległości zmniejszają się dwukrotnie, ale różne kontrakcje mogą mieć inne współczynniki zwężania, czasem nawet różne w różnych miejscach. Technicznie rzecz biorąc, uszczelka Sierpińskiego jest złożeniem trzech kontrakcji. Okazuje się, że ten sam obraz możemy otrzymać powtarzając taką sekwencję kroków: Wylosuj lub wybierz dowolny punkt startowy. Poniżej będzie to punkt (0,0), ale mógłby być też dowolny inny. Wylosuj jedną z kontrakcji, czyli jedno z trzech możliwych przekształceń w lewy, prawy lub górny róg. Przekształć punkt wylosowaną kontrakcją i narysuj wyznaczone współrzędne. Wróć do kroku 2. Powyższy algorytm należy powtórzyć nieskończoną liczbę razy, a jeżeli nam się spieszy to wystarczy zazwyczaj kilkadziesiąt tysięcy kroków. Spróbujmy! Poniżej zaczynamy z punktu (0,0), wykonamy 30 000 przekształceń. W każdym kroku za pomocą funkcji sample losujemy jedną z trzech przekształceń, które można zapisać matematycznie jako: \\(x&#39; = x/2\\), \\(y&#39; = y/2\\) (lewy róg) \\(x&#39; = x/2 + \\frac 12\\), \\(y&#39; = y/2\\) (prawy róg) \\(x&#39; = x/2 + \\frac 14\\), \\(y&#39; = y/2 + \\frac \\sqrt{3}2\\) (górny róg) A oto i kod N &lt;- 30000 x &lt;- 0 y &lt;- 0 # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,0.8), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:3, 1) switch(los, &#39;1&#39; = {x &lt;- x/2; y &lt;- y/2}, &#39;2&#39; = {x &lt;- x/2 + 1/2; y &lt;- y/2}, &#39;3&#39; = {x &lt;- x/2 + 1/4; y &lt;- y/2 + sqrt(3)/4}) points(x, y, pch = &quot;.&quot;, col=&quot;black&quot;) } Oto i nasza uszczelka! 3.4.2 Paproć Barnsleya Gra w chaos jest bardzo wygodnym sposobem tworzenia fraktali. Możemy zwiększać liczbę kontrakcji, zmieniać ich współczynniki otrzymując bardzo ciekawe efekty. Jednym z bardziej znanych fraktali wzorowanych na obiektach botanicznych jest paproć Barnsleya. W stosunku do uszczelki wprowadzimy dwie modyfikacje. Będziemy mieli cztery kontrakcje, ale też będziemy losować je z różnymi prawdopodobieństwami. Gdybyśmy mieli nieskończenie wiele czasu, to ta druga zmiana nie byłaby potrzebna, ale dla skończonej liczby kroków odpowiednie dobrane prawdopodobieństwa pozwolą nam szybciej wysycić odpowiednie elementy paproci. Kontrakcje dla paproci Barnsleya. \\(x&#39; = 0.85x + 0.04y\\), \\(y&#39; = -0.04x + 0.85y + 1.6\\) (górna część paproci) \\(x&#39; = -0.15x + 0.28y\\), \\(y&#39; = 0.26x + 0.24y + 0.44\\) (lewy listek) \\(x&#39; = 0.20x - 0.26y\\), \\(y&#39; = 0.23x + 0.22y + 1.6\\) (prawy listek) \\(x&#39; = 0\\), \\(y&#39; = 0.16y\\) (łodyżka) Będziemy losować te kontrakcje w proporcjach 85:7:7:1. A tutaj mamy kod dla R! N = 50000 x = 0 y = 0 # czyścimy ekran plot(0, xlim = c(-2.5,3), ylim = c(0,12), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:4, 1, prob = c(0.85, 0.07, 0.07, 0.01)) switch(los, &#39;1&#39; = {x &lt;- 0.85*x + 0.04*y; y &lt;- -0.04*x + 0.85*y + 1.6}, &#39;2&#39; = {x &lt;- -0.15*x + 0.28*y; y &lt;- 0.26*x + 0.24*y + 0.44}, &#39;3&#39; = {x &lt;- 0.20*x - 0.26*y; y &lt;- 0.23*x + 0.22*y + 1.6}, &#39;4&#39; = {x &lt;- 0; y &lt;- 0.16*y}) points(x, y, pch = &quot;.&quot;, col=&quot;black&quot;) } 3.5 Przykłady w Julia "],["podsumowanie.html", "Rozdział 4 Podsumowanie 4.1 Story 4.2 Wybrane fraktale", " Rozdział 4 Podsumowanie 4.1 Story Beta i Bit wracają do bazy 4.2 Wybrane fraktale http://www.algorytm.org/fraktale/system-funkcji-iterowanych-ifs.html 4.2.1 Trójkąt Sierpińskiego p1 = 0.3333 p2 = 0.3333 p3 = 0.3334 f1(0.5x + 0.0y - 0.5; 0.0x + 0.5y + 0.5) f2(0.5x + 0.0y - 0.5; 0.0x + 0.5y - 0.5) f3(0.5x + 0.0y + 0.5; 0.0x + 0.5y - 0.5) 4.2.2 Spirala p1 = 0.895652 p2 = 0.052174 p3 = 0.052174 f1(0.787879x - 0.424242y + 1.758647; 0.242424x + 0.859848y + 1.408065) f2(-0.121212x + 0.257576y - 6.721654; 0.151515x + 0.053030y + 1.377236) f3(0.181818x - 0.136364y + 6.086107; 0.090909x + 0.181818y + 1.568035) 4.2.3 Smok p1 = 0.787473 p2 = 0.212527 f1(0.824074x + 0.281428y - 1.882290; -0.212346x + 0.864198y - 0.110607) f2(0.088272x + 0.520988y + 0.785360; -0.463889x - 0.377778y + 8.095795) 4.2.4 Paproć Barnsley’a p1 = 0.01 p2 = 0.85 p3 = 0.07 p4 = 0.07 f1(0.0x + 0.0y + 0.0, 0.0x + 0.16y + 0.0) f2(0.85x + 0.04y + 0.0; -0.04x + 0.85y + 1.6) f3(0.2x - 0.26y + 0.0; 0.23x + 0.22y + 1.6) f4(-0.15x + 0.28y + 0.0; 0.26x + 0.24y + 0.44) 4.2.5 Liść klonu p1 = 0.1 p2 = 0.35 p3 = 0.35 p4 = 0.2 f1(0.14x + 0.01y - 1.31; 0.0x + 0.51y + 0.1) f2(0.43x + 0.52y + 1.49; -0.45x + 0.5y - 0.75) f3(0.45x - 0.49y - 1.62; 0.47x + 0.47y - 0.74) f4(0.49x + 0.0y + 0.02; 0.0x + 0.51y + 1.62) 4.2.6 Drzewo p1 = 0.142 p2 = 0.142 p3 = 0.142 p4 = 0.142 p5 = 0.142 p6 = 0.142 p7 = 0.142 f1(0.05x + 0.0y - 0.06; 0.0x + 0.4y - 0.47) f2(-0.05x + 0.0y - 0.06; 0.0x - 0.4y - 0.47) f3(0.03x - 0.14y - 0.16; 0.0x + 0.26y -0.01) f4(-0.03x + 0.14y - 0.16; 0.0x - 0.26y -0.01) f5(0.56x + 0.44y + 0.3; -0.37x + 0.51y + 0.15) f6(0.19x + 0.07y - 0.2; -0.1x + 0.15y + 0.28) f7(-0.33x - 0.34y - 0.54; -0.33x + 0.34y + 0.39) "],["podziękowania.html", "Podziękowania", " Podziękowania Gdy już ta książka powstanie, należy napisać bez kogo by nie powstała. "],["bibliografia.html", "Bibliografia", " Bibliografia "]]
