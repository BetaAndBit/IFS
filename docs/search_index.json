[["index.html", "Gra w chaos z przykładami w języku matematyki, R, Python i Julia 0.1 Dlaczego musiałem napisać tę książkę? 0.2 Jak czytać tę książkę", " Gra w chaos 2022-07-05 z przykładami w języku matematyki, R, Python i Julia 0.1 Dlaczego musiałem napisać tę książkę? Ponad ćwierć wieku temu, w drugiej klasie liceum, mój nauczyciel geometrii - prof. Wiesław Kostarczyk podrzucił mi książkę, która na nowo rozbudziła moje zainteresowanie matematyką. Były to ,,Fraktale od geometrii do sztuki’’ prof. Piotra Pierańskiego. Wtedy rozumiałem być może jedną piątą z tej książki, ale to wystarczyło. Krzywa, która jest tak gęsto upakowana w kwadracie, że choć ma zerowe pole to każdy niezerowy kwadracik zawiera jej kawałek? Dwa równoliczne zbiory, z których jeden na długość 0 a drugi długość 1? Paradoks za paradoksem. Pięć lat później znów trafiłem na fraktale, tym razem podczas studiów informatycznych. Okazało się, że te ciekawe figury mają nie tylko interesujące właściwości matematyczne, ale też bardzo ciekawą konstrukcje którą można zaprogramować! Ech, ile czasu spędziłem na wyszukiwaniu i oprogramowaniu różnych wariantów fraktali (a były to czasy raczkującego Internetu, więc trudno było znaleźć ciekawe konstrukcje, trzeba było głęboko kopać). Gdy 4 lata temu zacząłem pracować nad nowym programem ,,Matematyka Komiksowa’’, który miał na celu pokazać z użyciem komiksu ciekawe wyniki łączące matematyką i informatykę nie miałem wątpliwości! Musiałem napisać historię związaną z fraktalami. Chciałem też by była to wyjątkowa pozycja pokazująca fraktale z wielu perspektyw, ponieważ nigdy nie wiadomo która perspektywa okaże się najbardziej wciągająca. W tej książce znajdziecie urywki z życia trzech wielkich polskich matematyków związanych z fraktalami - Wacława Sierpińskiego, Stefana Banacha i Hugona Steinhausa. Z wyjątkiem pierwszego nie pracowali oni bezpośrednio nad fraktalami, ale jak się okazuje ich wyniki pomagają zrozumieć naturę tych figur. Historie te są pokazane przez krótkie komiksowe historyjki, mam nadzieję, że zainteresują one niektórych czytelników do sięgnięcia głębiej do ich życiorysów. Oczywiście nie mogło zabraknąć przedstawienia wybranych - istotnych twierdzeń - opisujących prawidła rządzące światem fraktali. Starałem się unikać terminologii wykraczającej poza słownik zainteresowanego matematyką licealisty. Mam nadzieję, że to zubożenie słownika zostanie mi wybaczone również przez kolegów matematyków. Zależało mi też na tym by przedstawić w tej książce też dokładne przepisy jak fraktale odtworzyć w zaciszu własnego komputera. Mamy więc programy rysujące fraktale w językach R, Python i Julia. Pisanie tej książki pozwoliło mi na nowo przeżyć ekscytacje sprzed lat bawiąc się w generowanie dziwnych figur. Mam nadzieję, że choć część tych emocji udzieli się też Tobie, drogi czytelniku. Przemysław Biecek. Wilga 2022. 0.2 Jak czytać tę książkę Tutaj będzie opis konstrukcji książki! "],["misja-wacław-sierpiński.html", "Rozdział 1 Misja: Wacław Sierpiński 1.1 Story 1.2 Teoria 1.3 Zakoduj mi fraktal", " Rozdział 1 Misja: Wacław Sierpiński 1.1 Story Strony_04_05 Strony_06_07 1.2 Teoria To fascynujące, że powtarzanie w nieskończoność tych samych czynności może prowadzić to arcyciekawych figur - fraktali. Taką figurę może narysować każdy, wystarczy podstawowa znajomość programowania. Krok po kroku pokażemy jak skonstruować różne klasy fraktali. Znajomość podstaw algebry, prawdopodobieństwa lub topologii pozwala dokładniej zrozumieć skąd się te zaskakujące figury biorą. 1.2.1 Kurz Cantora Jedną z ciekawszych metod konstrukcji fraktali jest metoda ,,przez wygryzanie’’. Bierzemy pewną figurę a następnie usuwamy z niej (wygryzamy) kawałki. To co zostaje jest fraktalem, często o zaskakujących właściwościach. Zilustrujmy to na przykładzie fraktalu nazywanego kurzem Cantora. Receptura na konstrukcje kurzu Cantora jest prosta: Weź odcinek o dowolnej długości (ale dla uproszczenia nasz będzie miał długość 1). Podziel ten odcinek na trzy równe części. Usuń wnętrze środkowej części, przez co otrzymasz dwa odcinki, oba o długości 1/3 wyjściowego odcinka. Dla każdego z otrzymanych odcinków kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 1. Rysunek 1: Pierwsze 5 iteracji w konstrukcji kurzu Cantora Powyższy algorytm ma kilka elementów typowych dla fraktali. Po pierwsze nigdy się nie kończy, całą procedurę należy (przynajmniej w teorii) powtarzać nieskończenie wiele razy. Po drugie, mamy do czynienia z rekurencją, pewien krok prowadzi do powstania zbioru obiektów a następnie każdy z tych obiektów jest ponownie przekształcany w ten sam sposób. W bardzo podobny sposób można otrzymać wiele ciekawych fraktali, ale przyjrzyjmy się jeszcze przez chwilę kurzowi Cantora. Zobaczmy co my właściwie otrzymaliśmy w wyniku tej procedury. Sprawdźmy może jak duży jest ten obiekt lub jaką ma długość. Początkowo odcinek miał długość \\(1\\), ale w pierwszym kroku usunęliśmy \\(1/3\\). W drugim kroku usunęliśmy \\(2\\) razy po \\((1/3)^2\\). Powtarzając to kilkukrotnie w kroku \\(k\\) usuwamy \\(2^{k-1}\\) odcinków, każdy o długości \\((1/3)^k\\). A więc długość tego tworu w kroku \\(k\\) to \\[ 1 - 1/3 - 2*(1/3)^2 - ... - 2^{k-1}*(1/3)^k = 1 - \\sum_{i=1}^k 2^{k-1}*(1/3)^k = 1 - 1/2 \\sum_{i=1}^k (2/3)^k = 0 \\] Do tego samego wniosku można dojść stosując inne rozumowanie, a mianowicie patrząc, ile zostało po \\(k\\) kroku. Po pierwszym kroku mamy \\(2\\) odcinki długości \\(1/3\\), po drugim kroku mamy \\(2^2\\) odcinków długości \\((1/3)^2\\) a po \\(k\\) kroku mamy \\(2^k\\) odcinków o długości \\((1/3)^k\\). Do czego zbiega ten szereg? \\[ \\lim_{k \\rightarrow \\infty} (2/3)^k = 0 \\] Nie ma więc wątpliwości, zbiór Cantora ma długość równą \\(0\\). Ale ewidentnie nie jest zbiorem pustym, bo ma wiele punktów. Jak wiele? Okazuje się, że tyle samo co cały odcinek, a więc nieprzeliczalnie wiele. Pokażmy to za pomocą pewnego sprytnego dowodu. Twierdzenie: Zbiór Cantora jest równoliczny z odcinkiem [0-1). Dowód: Aby policzyć punkty w zbiorze Cantora, potrzebujemy dla każdego punktu skonstruować rodowód, a więc zapis pozwalający jednoznacznie zidentyfikować każdy punkt. Rodowodem jednoznacznie identyfikującym punkt nazwiemy zbiór decyzji, określających jak do tego punktu dotrzeć w kolejnych krokach procedury generującej kurz Cantora. Pamiętamy, że w każdym kroku usuwane są środku z odcinków, więc punkt, który należy do kurzu będzie leżał albo w lewym albo w prawym odcinku. Ten wybór (lewy/prawy) trzeba podjąć w każdym kroku konstrukcji kurzu. Taki rodowód możemy zapisać przez nieskończoną sekwencje cyfr 0/1, jeżeli w sekwencji na pozycji k występuje 0 to punkt należy do lewego pododcinka, jeżeli 1 to do prawego. Zauważmy, jednoznaczność -&gt; każdy punkt z kurzu Cantora może być opisany przez nieskończoną sekwencje cyfr 0/1. Jednocześnie każda nieskończona sekwencja cyfr opisuje jakiś punkt ze zbioru Cantora, a różne sekwencje opisują różne punkty. Ile jest takich sekwencji? Kontinuum. Wystarczy bowiem myśleć o tych sekwencjach jak o rozwinięciach dwójkowych liczb z przedziału [0,1]. Co więc mamy? Kurz Cantora ma tyle samo punktów co odcinek [0,1]. Ale jednocześnie ma długość 0, choć odcinek ma oczywiście długość 1. Jak to możliwe? To jedna z wielu zagadek kryjących się w krainie fraktali malowanych nieskończonością. 1.2.2 Trójkąt Sierpińskiego Jeden z najbardziej znanych fraktali to trójkąt Sierpińskiego. Receptura na konstrukcje tego trójkąt jest dosyć podobna do kurzu Cantora. Oto dokładny przepis: Weź trójkąt równoboczny o dowolnej wielkości (ale dla uproszczenia nasz trójkąt będzie miał długość boku 1). Podziel ten trójkąt na cztery równe trójkąty równoboczne. Usuń środkowy trójkąt, przez co otrzymasz trzy trójkąty, oba o wielkości boku 1/2 wyjściowego trójkąta Dla każdego z otrzymanych trójkątów kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 2. Rysunek 2: Pierwsze cztery iteracje w konstrukcji trójkąta Sierpińskiego Ładny to twór. Ale jakie ma właściwości? Jakie jest jego pole? Tutaj już szybkie rachunki pozwalają rozwiać wszelkie wątpliwości. W kroku \\(k\\) trójkąt składa się z \\(3^k\\) trójkątów, każdy o boku \\((1/2)^k\\), czyli polu \\(\\sqrt{3}/2^{2k+1}\\), czyli o łącznym polu \\((3/4)^k*\\sqrt{3}/2\\). W granicy mamy więc \\[ \\lim_{k \\rightarrow \\infty} (3/4)^k*\\sqrt{3}/2 = 0 \\] Więc trójkąt Sierpińskiego jest tak dziurawy, że ma pole równe 0. A jak długi jest jego brzeg? W kroku \\(k\\) brzeg zwiększa się o \\(3^{k-1}\\) trójkątów, każdy o boku \\((1/2)^k\\), czyli obwodzie \\(3*(1/2)^k\\). Czyli łaczny brzeg w kroku \\(k\\) to \\[ \\sum_{i=1}^k 3^{k-1}*3*(1/2)^k = \\sum_{i=1}^k (3/2)^k. \\] Elementy tego szeregu rosną do nieskończoności, więc tym bardziej cały obwód też eksploduje do nieskończoności. \\[ \\lim_{k \\rightarrow \\infty}\\sum_{i=1}^k (3/2)^k = \\infty \\] Co to za figura, jest ograniczona bo się mieści w trójkącie o boku 1, ale ma nieskończony obwód przy zerowym polu. Z jakiego to jest wymiaru? 1.2.3 Wymiar Hausdorfa Prawdopodobnie do tego miejsca część czytelników zadaje sobie pytanie czym są fraktale. Czy to takie dziwne obrazki? A jeżeli tak to jak je scharakteryzować? Jedną z częściej powtarzanych definicji fraktali jest definicja podana przez Mandelbrota, którą sparafrazuję do: Fraktalem nazywamy taki zbiór, którego wymiar Hausdorfa nie jest liczbą całkowitą. Ok, a czym jest ten wymiar Hausdorfa? Gdy myślimy o przestrzeniach Euklidesowych wymiarem określano liczbę ortogonalnych kierunków/wektorów rozpinających daną przestrzeń. I tak punkt ma wymiar 0, prosta ma wymiar 1, płaszczyzna ma wymiar 2, wszyscy doświadczamy trójwymiarowej przestrzeni. Czasem pewne obiekty możemy opisywać też w przestrzeniach o wyższych wymiarach i nie ma tu żadnych ograniczeń. Matematyk z podekscytowaniem w głosie może opowiadać o przestrzeni funkcji, która jest nieskończenie wymiarowa. Wymiar Hausdorfa określa się dla obiektów geometrycznych zanurzonych w zwykłych \\(p\\)-wymiarowych przestrzeniach (my ograniczymy się praktycznie wyłącznie do \\(p=2\\)). Aby go wyznaczyć, musimy policzyć iloma \\(p\\) wymiarowymi kostkami o boku \\(\\varepsilon\\) można przykryć interesujący nas obiekt. Jeżeli przez \\(N(\\varepsilon)\\) określimy minimalną liczbę kostek pokrywających obiekt \\(F\\) to wymiarem Hausdorfa \\(d_F\\) tego obiektu jest \\[ d_F = \\lim_{\\varepsilon \\rightarrow 0} \\frac{\\log N(\\varepsilon)}{\\log 1/\\varepsilon} \\] Przyjmijmy na razie, że interesują nas kostki o boku \\(\\varepsilon = 2^{-k}\\). Jeżeli chcemy przykryć nimi kwadrat o boku \\(1\\) to potrzebujemy ich przynajmniej \\(N(\\varepsilon) = 2^k * 2^k = 2^{2k}\\). Więc wymiar Hausdorfa kwadratu to \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 2^{2k}}{\\log 1/2^{-k}} = 2 \\] A co z trójkątem Sierpińskiego? Tutaj wystarczy nam \\(N(\\varepsilon) = 3^k\\) kostek o boku \\(2^{-k}\\), a więc wymiar Hausdorfa dla tego trójkąta to \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 3^{k}}{\\log 1/2^{-k}} = \\frac{\\log 3}{\\log 2} = 1,5849... \\] Rysunek 3 ilustruje jak wygląda przykładowe pokrycie trójkąta Sierpińskiego takimi kostkami. Rysunek 3: Pokrycie trójkąta Sierpińskiego kostkmi o boku 1/4 (lewy panel) i 1/8 (prawy panel) A jak to wygląda dla kurzu Cantora? Tym razem mamy obiekt zanurzony w przestrzeni jednowymiarowej, więc będziemy go przykrywać odcinkami. Przyjmijmy, że mamy odcinki o długości \\(\\varepsilon = 3^{-k}\\), aby pokryć cały kurz Cantora wystarczy nam takich odcinków \\(N(\\varepsilon) = 2^k\\), czyli wymiar Hausdorfa dla kurzu Cantora \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 2^{k}}{\\log 1/3^{-k}} = \\frac{\\log 2}{\\log 3} = 0,6309... \\] Wymiar mniejszy niż 1? To nic nadzwyczajnego w świecie fraktali. 1.2.4 Dywan Sierpińskiego Receptura na konstrukcje dywanu Sierpińskiego jest podobna do trójkąta. Oto dokładny przepis: Weź kwadrat o dowolnej wielkości (ale dla uproszczenia nasz kwadrat będzie miał długość boku 1). Podziel ten kwadrat na dziewięć równych kwadratów. Usuń środkowy kwadrat, przez co otrzymasz osiem kwadratów o wielkości boku 1/3 wyjściowego kwadratu. Dla każdego z otrzymanych kwadrat kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 4. Rysunek 4: Pierwsze cztery iteracje w konstrukcji dywanu Sierpińskiego Jaki jest wymiar Hausdorfa tego tworu? Weźmy kostki o wielkości \\(\\varepsilon = 3^{-k}\\). Do zakrycia dywanu wystarczy nam \\(N(\\varepsilon) = 8^k\\) kostek o boku \\(3^{-k}\\). Więc wymiar Hausdorfa dla tego dywanu to \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 8^{k}}{\\log 1/3^{-k}} = \\frac{\\log 8}{\\log 3} = 1,8927... \\] 1.3 Zakoduj mi fraktal 1.3.1 Trójkąt Sierpińskiego w R W programie R nie ma funkcji rysującej trójkąty, więc musimy ją najpierw zdefiniować. Do tego celu używamy funkcji polygon, która rysuje wypełnione zamknięte wielokąty. Na jej bazie definiujemy funkcje trojkat rysującą trójkąt równoboczny o boku bok zaczepiony lewym dolnym rogiem w punkcie (x, y). trojkat &lt;- function(x, y, bok) { polygon(x + bok*c(0, 1, 1/2), y + bok*c(0, 0, sqrt(3)/2), col = &quot;black&quot;) } Przetestujmy tę funkcję. Najpierw funkcją plot.new otworzymy nowy obszar do rysowania o wymiarach 1x1 a następnie narysujemy trójkąt o boku 1. plot.new() trojkat(0, 0, 1) Jeżeli chcielibyśmy narysować drugi krok konstrukcji trójkąta Sierpińskiego to musielibyśmy wywołać funkcję trojkat trzy razy. plot.new() trojkat(0, 0, 0.5) trojkat(0.5, 0, 0.5) trojkat(0.25, sqrt(3)/4, 0.5) Aby narysować trzeci krok należałoby wywołać tę funkcję \\(3^2\\) razy. plot.new() trojkat(0, 0, 0.25) trojkat(0.25, 0, 0.25) trojkat(0.125,sqrt(3)/8, 0.25) trojkat(0.5, 0, 0.25) trojkat(0.75, 0, 0.25) trojkat(0.625, sqrt(3)/8, 0.25) trojkat(0.25, sqrt(3)/4, 0.25) trojkat(0.50, sqrt(3)/4, 0.25) trojkat(0.375,3*sqrt(3)/8, 0.25) Rysowanie kolejnych kroków kopiując linijki z funkcją trojkat byłoby niepraktyczne. Znacznie lepiej wykorzystać rekurencje. Poniżej tworzymy funkcje fraktal_trojkat, która w kroku 0 rysuje w trójkąt o zadanym boku a w innych krokach wywoluje się z poleceniem narysowani trzech miejszych fraktali o boku będącym połową wyjściowego. fraktal_trojkat &lt;- function(x, y, bok, krok = 0) { if (krok == 0) { trojkat(x, y, bok) } else { fraktal_trojkat(x, y, bok/2, krok - 1) fraktal_trojkat(x+bok/2, y, bok/2, krok - 1) fraktal_trojkat(x+bok/4, y+sqrt(3)*bok/4, bok/2, krok - 1) } } Wypróbujmy ją! Może na początek ustawmy 5 iteracji, przez co narysujemy \\(3^5 = 243\\) trójkątów. plot.new() fraktal_trojkat(0, 0, bok = 1, krok = 5) Bardzo bardzo mały trójkąt wygląda jak punkt Zamiast rysować trójkąt wystarczy narysować jeden punkt, bo trójkąty po pewnym czasie i tak są strasznie małe. Tyle, że trójkąt Sierpińskiego składająca się z \\(243\\) punktów jest dosyć dziurawa. Dlatego sprawdzimy jak wygląda dla 8 iteracji. plot.new() fraktal_punkt &lt;- function(x, y, bok, krok = 0) { if (krok == 0) { points(x, y, pch=&quot;.&quot;, col=&quot;black&quot;) } else { fraktal_punkt(x, y, bok/2, krok - 1) fraktal_punkt(x+bok/2, y, bok/2, krok - 1) fraktal_punkt(x+bok/4, y+sqrt(3)*bok/4, bok/2, krok - 1) } } fraktal_punkt(0, 0, bok = 1, krok = 8) Ile punktów narysowaliśmy? 1.3.2 Dywan Sierpińskiego w R Prace z fraktalami rozpoczniemy od utkania Dywanu Sierpińskiego. Zaczniemy od jego zubożonej wersji, którą trochę łatwiej opisać na początku, a później pokażemy przepis na kompletny dywan. Jest to dobry fraktal na początek, wystarczy: narysować kwadrat pomniejszyć rysunek 3 razy skopiować 4 razy w cztery rogi kwadratu z otrzymanym rysunkiem wrócić do kroku 2 i tak w nieskończoność. Pierwsze trzy iteracje powyższego schematu przedstawione są na rysunku poniżej. images/fraktale_01.png Ok, spróbujmy to zrobić w R. 1.3.2.1 Narysuj mi kwadrat Zacznijmy od narysowania kwadratu. Pierwsza linijka poniższego przykładu tworzy pusty obszar do rysowania o wymiarach [0,1]x[0,1]. Druga linijka zawiera instrukcje rect(), która rysuje czarny kwadrat rozpięty od punktu (0,0) do (1,1). # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rect(0, 0, 1, 1, col = &quot;black&quot;) W drugiej iteracji ten kwadrat jest trzykrotnie pomniejszany do wymiarów 1/3 x 1/3 i rysowany w czterech rogach. Mamy do narysowania cztery kwadraty i możemy to zrobić w poniższy sposób. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rect(0, 0, 1/3, 1/3, col = &quot;black&quot;) rect(0+2/3, 0, 1/3+2/3, 1/3, col = &quot;black&quot;) rect(0, 0+2/3, 1/3, 1/3+2/3, col = &quot;black&quot;) rect(0+2/3, 0+2/3, 1/3+2/3, 1/3+2/3, col = &quot;black&quot;) W trzeciej iteracji w miejsce każdego z tych czterech kwadratów rysujemy kolejne 4 kwadraty trzykrotnie pomniejszone. W sumie będzie to 16 kwadratów, sporo ale jeszcze damy radę to zapisać. Można to zrobić tak # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rect(0, 0, 1/9, 1/9, col = &quot;black&quot;) rect(0+2/9, 0, 1/9+2/9, 1/9, col = &quot;black&quot;) rect(0, 0+2/9, 1/9, 1/9+2/9, col = &quot;black&quot;) rect(0+2/9, 0+2/9, 1/9+2/9, 1/9+2/9, col = &quot;black&quot;) rect(0+2/3, 0, 1/9+2/3, 1/9, col = &quot;black&quot;) rect(0+2/3+2/9, 0, 1/9+2/3+2/9, 1/9, col = &quot;black&quot;) rect(0+2/3, 0+2/9, 1/9+2/3, 1/9+2/9, col = &quot;black&quot;) rect(0+2/3+2/9, 0+2/9, 1/9+2/3+2/9, 1/9+2/9, col = &quot;black&quot;) rect(0, 0+2/3, 1/9, 1/9+2/3, col = &quot;black&quot;) rect(0+2/9, 0+2/3, 1/9+2/9, 1/9+2/3, col = &quot;black&quot;) rect(0, 0+2/3+2/9, 1/9, 1/9+2/3+2/9, col = &quot;black&quot;) rect(0+2/9, 0+2/3+2/9, 1/9+2/9, 1/9+2/3+2/9, col = &quot;black&quot;) rect(0+2/3, 0+2/3, 1/9+2/3, 1/9+2/3, col = &quot;black&quot;) rect(0+2/3+2/9, 0+2/3, 1/9+2/3+2/9, 1/9+2/3, col = &quot;black&quot;) rect(0+2/3, 0+2/3+2/9, 1/9+2/3, 1/9+2/3+2/9, col = &quot;black&quot;) rect(0+2/3+2/9, 0+2/3+2/9, 1/9+2/3+2/9, 1/9+2/3+2/9, col = &quot;black&quot;) Aby narysować dywan sierpińskiego musimy tę procedurę powtórzyć przynajmniej kilka razy, co wymaga narysowania tysięcy, a często jeszcze większej liczby, kwadratów. Przy takiej liczbie kwadratów kopiowanie kolejnych linijek z wywołaniem funkcji rect nie ma sensu. 1.3.2.2 Rekurencja Zrobimy to sprytniej używając rekurencji, czyli funkcji, która sama siebie wywołuje. Skorzystamy z cechy, która nazywa się samopodobieństwem, czyli cały dywan jest podobny do swoich części. Poniższy przykład przedstawia bardzo sprytną funkcję rysuj_dywan(). Ma ona kilka ciekawych argumentów. Pierwsze dwa x i y wskazują w którym miejscu ma być rysowany dywan, trzeci szerokosc określa szerokość rysowanego dywanu, a ostatni iteracja określa ile iteracji powyższego algorytmu powinniśmy wykonać by narysować dywan. Jeżeli funkcja rysuj_dywan() zostanie wywołana z argumentem iteracja = 0 to narysuje sam kwadrat. Ale jeżeli zostanie wykonana z innym argumentem to narysuje cztery dywany zaczepione w rogach kwadratu o szerokości \\(1/3\\) wyjściowego dywanu. Zobaczmy co z tego wyjdzie! # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan &lt;- function(x, y, szerokosc, iteracja = 0) { if (iteracja == 0) { rect(x, y, x + szerokosc, y + szerokosc, col = &quot;black&quot;) } else { rysuj_dywan(x, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) } } rysuj_dywan(0, 0, szerokosc = 1, iteracja = 2) Możemy teraz w prosty sposób narysować kolejne iteracje małym nakładem kodu. Na trzecim poziomie będzie to \\(4^3 = 64\\) kwadratów. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan(0, 0, szerokosc = 1, iteracja = 3) Zobaczmy jak będzie ta figura wyglądała dla piątej iteracji. Mamy już do czynienia z \\(4^5 = 2^10 = 1024\\) kwadratami. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan(0, 0, szerokosc = 1, iteracja = 5) 1.3.2.3 Prawdziwy dywan Widzimy już jak działa rekurencja oraz co się dzieje w kolejnych iteracjach. Jesteśmy gotowi do narysowania pełnego dywanu Sierpińskiego. Różnica jest taka, że w każdym kroku, zamiast czterech kwadratów w rogach, będziemy rysować 8 kwadratów ,,po obwodzie’’ dużego kwadratu. W poniższej funkcji w każdym kroku z iteracja różnym od 0, rysujemy 8 mniejszych dywanów. rysuj_dywan &lt;- function(x, y, szerokosc, iteracja = 0) { if (iteracja == 0) { rect(x, y, x + szerokosc, y + szerokosc, col = &quot;black&quot;) } else { rysuj_dywan(x, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) } } Rysowanie dywanu dla pięciu iteracji może trochę trwać, ponieważ składa się z \\(8^5 = 2^15 = 32768\\) kwadratów. Ale warto chwilę poczekać by uzyskać taki wynik. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan(0, 0, szerokosc = 1, iteracja = 5) Oczywiście możemy zwiększać liczbę iteracji, ale zmiany na obrazku przestają być zauważalne. 1.3.2.4 Bardzo bardzo mały kwadrat wygląda jak punkt Zauważmy, że narysowany kwadrat bardzo szybko maleje. Maleje wręcz z wykładniczą prędkością. Więc po wielu iteracjach nie musimy rysować kwadratu, wystarczy, że narysujemy punkt, mniej zachodu. Sprawdźmy czy tak faktycznie jest. Zmienimy funkcję rysuj_dywan() by w finalnej iteracji rysowała punkt. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan &lt;- function(x, y, szerokosc, iteracja = 0) { if (iteracja == 0) { points(x, y, col = &quot;black&quot;, pch=&quot;.&quot;) } else { rysuj_dywan(x, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) } } rysuj_dywan(0, 0, szerokosc = 1, iteracja = 5) Tada! Również otrzymujemy dywan, trochę bardziej dziurawy. W zależności od rozdzielczości ekranu warto zwiększyć liczbę iteracji do sześciu lub siedmiu, by dywan się ,,nasycił’’. 1.3.3 Trójkąt Sierpińskiego w Python import numpy as np import matplotlib.pyplot as plt def trojkat(x, y, bok): E = np.array([[x+bok*0,y+bok*0], [x+bok*1,y+bok*0], [x+bok*1/2,y+bok*np.sqrt(2)/2], [x+bok*0,y+bok*0]]) return plt.Polygon(E, facecolor = &#39;k&#39;) 1.3.4 Trójkąt Sierpińskiego w Julia using Plots function trojkat(x, y, bok) return [(x+bok*0,y+bok*0),(x+bok*1,y+bok*0),(x+bok*1/2,y+bok*sqrt(2)/2),(x+bok*0,y+bok*0)] end # czyścimy ekran E = 0.05 Plots.plot(0,xlim=(0-E,1+E),ylim=(0-E,1+E-0.1)) function rysuj_uszczelke(x, y, szerokosc, iteracja) if iteracja == 0 Plots.plot!(trojkat(x, y, szerokosc), seriestype=:shape, color=:black, legend=:false) else rysuj_uszczelke(x, y, szerokosc / 2, iteracja - 1) rysuj_uszczelke(x+szerokosc / 2, y, szerokosc / 2, iteracja - 1) rysuj_uszczelke(x+szerokosc / 4, y+sqrt(3)*szerokosc/4, szerokosc / 2, iteracja - 1) end current() end rysuj_uszczelke(0, 0, 1, 5) using Plots # czyścimy ekran E = 0.05 Plots.plot(0,xlim=(0-E,1+E),ylim=(0-E,1+E-0.1)) function rysuj_uszczelke(x, y, szerokosc, iteracja) if iteracja == 0 Plots.scatter!([x], [y], markerstrokecolor=:white, markersize=3, color=:black, legend=:false) else rysuj_uszczelke(x, y, szerokosc/2, iteracja - 1) rysuj_uszczelke(x+szerokosc/2, y, szerokosc/2, iteracja - 1) rysuj_uszczelke(x+szerokosc/4, y+sqrt(3)*szerokosc/4, szerokosc/2, iteracja - 1) end current() end rysuj_uszczelke(0, 0, 1, 8) "],["misja-stefan-banach.html", "Rozdział 2 Misja: Stefan Banach 2.1 Story 2.2 Teoria 2.3 Algebra, wszędzie algebra 2.4 Zakoduj mi fraktal", " Rozdział 2 Misja: Stefan Banach 2.1 Story Strony_08_09 Strony_10_11 2.2 Teoria 2.3 Algebra, wszędzie algebra Powyżej opisane przekształcenia to tzw. przekształcenia afiniczne, czyli złożenie skalowania, obrotu i przesunięcia. Skalowanie musi zmniejszać, obrót i przesunięcie mogą być dowolne. Przekształcenia afiniczne można łatwo opisać w postaci algebraicznej, jako mnożenie punktu przez macierz przekształcenia. Pozwoli nam to skrócić zapis kodu, generującego fraktal. W przykładzie poniżej, trans będzie listą transformacji opisanych przez macierz przekształcenia. Na płaszczyźnie, aby opisać skalowanie i obrót wystarczyłaby macierz o wymiarach \\(2\\times 2\\), ale jeżeli chcemy umożliwić przesunięcia, to takie transformacie opiszemy macierzami \\(2\\times 3\\). Mając macierz przekształcenia \\(A\\) możemy wyznaczyć współrzędne punkty po przekształceniu stosując iloczyn macierzowy. W poniższym równaniu dla ułatwienia podano wymiary macierzy. \\[ [x&#39;\\ y&#39;]_{2\\times 1} = A_{2\\times 3} * [x\\ y\\ 1]_{3\\times 1} \\] 2.4 Zakoduj mi fraktal Ok, czas to zapisać w R. Obiekt trans będzie listą czterech transformacji a prob będzie prawdopodobieństwem z jakim kolejne transformacje powinny być losowane. N = 50000 point &lt;- c(0, 0) # transformacje trans &lt;- list() trans[[1]] &lt;- matrix(c( 0.85, 0.04, 0, -0.04, 0.85, 1.6), 2, 3, byrow = TRUE) trans[[2]] &lt;- matrix(c(-0.15, 0.28, 0, 0.26, 0.24, 0.44), 2, 3, byrow = TRUE) trans[[3]] &lt;- matrix(c( 0.20, -0.26, 0, 0.23, 0.22, 1.6), 2, 3, byrow = TRUE) trans[[4]] &lt;- matrix(c( 0, 0, 0, 0, 0.16, 0), 2, 3, byrow = TRUE) prob = c(0.85, 0.07, 0.07, 0.01) # czyścimy ekran plot(0, xlim = c(-2.5,3), ylim = c(0,12), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:length(trans), 1, prob = prob) point &lt;- trans[[los]] %*% c(point, 1) points(point[1], point[2], pch = &quot;.&quot;, col=&quot;black&quot;) } 2.4.1 Smok Heighwaya Dobierając różne transformacje uzyskamy bardzo różne fraktale. Przykładowo Smok Heighwaya to złożenie dwóch transformacji \\(x&#39; = -0.4x -1\\), \\(y&#39; = -0.4y + 0.1\\) \\(x&#39; = 0.76x -0.4y\\), \\(y&#39; = 0.4x + 0.76y\\) A tutaj kod w R. Wystarczy zmienić opis transformacji a druga część kodu pozostaje bez zmian. N = 100000 point &lt;- c(0, 0) trans &lt;- list() trans[[1]] &lt;- matrix(c( -0.4, 0, -1, 0, -0.4, 0.1), 2, 3, byrow = TRUE) trans[[2]] &lt;- matrix(c( 0.76, -0.4, 0, 0.4, 0.76, 0), 2, 3, byrow = TRUE) prob = c(0.5, 0.5) # czyścimy ekran plot(0, xlim = c(-1.5,0.5), ylim = c(-1,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:length(trans), 1, prob = prob) point &lt;- trans[[los]] %*% c(point, 1) points(point[1], point[2], pch = &quot;.&quot;, col=&quot;black&quot;) } 2.4.2 Do It Yourself! Poszukaj i spróbuj zaimplementować inne fraktale, jak np: pentagon Sierpińskiego https://larryriddle.agnesscott.org/ifs/pentagon/pentagon.htm płatek Kocha https://larryriddle.agnesscott.org/ifs/ksnow/ksnow.htm McWorter’s Pentigree https://larryriddle.agnesscott.org/ifs/pentigre/pentigre2.htm Opisana powyżej metoda konstrukcji fraktali nazywa się systemem funkcji iterowanych (ang. iterated function system, IFS). Składane funkcje nie muszą być przekształceniami afinicznymi, wystarczy by były kontrakcjami. Eksperymentując z innymi przekształceniami można uzyskać bardzo ciekawe wyniki. "],["misja-hugon-steinhaus.html", "Rozdział 3 Misja: Hugon Steinhaus 3.1 Story 3.2 Teoria 3.3 Zakoduj mi fraktal 3.4 Zakoduj mi fraktal w Julia", " Rozdział 3 Misja: Hugon Steinhaus 3.1 Story Strony_12_13 Strony_14_15 3.2 Teoria 3.3 Zakoduj mi fraktal Pewną wadą rysowania fraktali w sposób opisany powyżej, jest wykładnicze tempo z jakim przybywa nowych obiektów. 8 iteracji to już jest dużo. Gdybyśmy chcieli wykonać 56 iteracji dla dywanu Sierpińskiego to musielibyśmy narysować \\(8^{56} &lt; 10^{50}\\) punktów, czyli więcej niż jest atomów na całej ziemi! Na szczęście jest też druga metoda rysowania fraktali, w której nie musimy używać rekurencji. Musimy za to dużo rysować, ale jak się okaże dzięki temu będziemy w stanie rysować fantastyczne inne fraktale. 3.3.1 Wylosuj mi transformacje Zademonstrujemy grę w chaos na przykładzie uszczelki Sierpińskiego. W poprzednim rozdziale, rysowaliśmy tą uszczelkę rysując trzy mniejsze uszczelki poprzesuwane w rogi trójkąta. Każda z tych uszczelek jest przekształceniem większej uszczelki. Co więcej to tak zwane przekształcenie zwężające (kontrakcja), czyli takie, które zmniejsza odległości pomiędzy punktami. W przypadku naszej uszczelki odległości zmniejszają się dwukrotnie, ale różne kontrakcje mogą mieć inne współczynniki zwężania, czasem nawet różne w różnych miejscach. Technicznie rzecz biorąc, uszczelka Sierpińskiego jest złożeniem trzech kontrakcji. Okazuje się, że ten sam obraz możemy otrzymać powtarzając taką sekwencję kroków: Wylosuj lub wybierz dowolny punkt startowy. Poniżej będzie to punkt (0,0), ale mógłby być też dowolny inny. Wylosuj jedną z kontrakcji, czyli jedno z trzech możliwych przekształceń w lewy, prawy lub górny róg. Przekształć punkt wylosowaną kontrakcją i narysuj wyznaczone współrzędne. Wróć do kroku 2. Powyższy algorytm należy powtórzyć nieskończoną liczbę razy, a jeżeli nam się spieszy to wystarczy zazwyczaj kilkadziesiąt tysięcy kroków. Spróbujmy! Poniżej zaczynamy z punktu (0,0), wykonamy 30 000 przekształceń. W każdym kroku za pomocą funkcji sample losujemy jedną z trzech przekształceń, które można zapisać matematycznie jako: \\(x&#39; = x/2\\), \\(y&#39; = y/2\\) (lewy róg) \\(x&#39; = x/2 + \\frac 12\\), \\(y&#39; = y/2\\) (prawy róg) \\(x&#39; = x/2 + \\frac 14\\), \\(y&#39; = y/2 + \\frac \\sqrt{3}2\\) (górny róg) A oto i kod N &lt;- 30000 x &lt;- 0 y &lt;- 0 # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,0.8), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:3, 1) switch(los, &#39;1&#39; = {x &lt;- x/2; y &lt;- y/2}, &#39;2&#39; = {x &lt;- x/2 + 1/2; y &lt;- y/2}, &#39;3&#39; = {x &lt;- x/2 + 1/4; y &lt;- y/2 + sqrt(3)/4}) points(x, y, pch = &quot;.&quot;, col=&quot;black&quot;) } Oto i nasza uszczelka! 3.3.2 Paproć Barnsleya Gra w chaos jest bardzo wygodnym sposobem tworzenia fraktali. Możemy zwiększać liczbę kontrakcji, zmieniać ich współczynniki otrzymując bardzo ciekawe efekty. Jednym z bardziej znanych fraktali wzorowanych na obiektach botanicznych jest paproć Barnsleya. W stosunku do uszczelki wprowadzimy dwie modyfikacje. Będziemy mieli cztery kontrakcje, ale też będziemy losować je z różnymi prawdopodobieństwami. Gdybyśmy mieli nieskończenie wiele czasu, to ta druga zmiana nie byłaby potrzebna, ale dla skończonej liczby kroków odpowiednie dobrane prawdopodobieństwa pozwolą nam szybciej wysycić odpowiednie elementy paproci. Kontrakcje dla paproci Barnsleya. \\(x&#39; = 0.85x + 0.04y\\), \\(y&#39; = -0.04x + 0.85y + 1.6\\) (górna część paproci) \\(x&#39; = -0.15x + 0.28y\\), \\(y&#39; = 0.26x + 0.24y + 0.44\\) (lewy listek) \\(x&#39; = 0.20x - 0.26y\\), \\(y&#39; = 0.23x + 0.22y + 1.6\\) (prawy listek) \\(x&#39; = 0\\), \\(y&#39; = 0.16y\\) (łodyżka) Będziemy losować te kontrakcje w proporcjach 85:7:7:1. A tutaj mamy kod dla R! N = 50000 x = 0 y = 0 # czyścimy ekran plot(0, xlim = c(-2.5,3), ylim = c(0,12), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:4, 1, prob = c(0.85, 0.07, 0.07, 0.01)) switch(los, &#39;1&#39; = {x &lt;- 0.85*x + 0.04*y; y &lt;- -0.04*x + 0.85*y + 1.6}, &#39;2&#39; = {x &lt;- -0.15*x + 0.28*y; y &lt;- 0.26*x + 0.24*y + 0.44}, &#39;3&#39; = {x &lt;- 0.20*x - 0.26*y; y &lt;- 0.23*x + 0.22*y + 1.6}, &#39;4&#39; = {x &lt;- 0; y &lt;- 0.16*y}) points(x, y, pch = &quot;.&quot;, col=&quot;black&quot;) } 3.4 Zakoduj mi fraktal w Julia "],["podsumowanie.html", "Rozdział 4 Podsumowanie 4.1 Story", " Rozdział 4 Podsumowanie 4.1 Story Strony_16_17 "],["podziękowania.html", "Podziękowania", " Podziękowania Gdy już ta książka powstanie, należy napisać bez kogo by nie powstała. "],["bibliografia.html", "Bibliografia", " Bibliografia "]]
